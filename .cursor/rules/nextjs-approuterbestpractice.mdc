---
description: 
globs: 
alwaysApply: false
---
# Next.js App Router ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

Next.js App Routerã¨Server Actionsã‚’ä½¿ç”¨ã—ãŸãƒ•ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹ç™ºã®ãŸã‚ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã‚¬ã‚¤ãƒ‰ã€‚

## ğŸ“ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ 

### ãƒ•ã‚¡ã‚¤ãƒ«é…ç½®
```
app/
â”œâ”€â”€ (auth)/              # Route Groups - èªè¨¼é–¢é€£ãƒšãƒ¼ã‚¸
â”‚   â”œâ”€â”€ login/
â”‚   â””â”€â”€ signup/
â”œâ”€â”€ dashboard/           # ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰æ©Ÿèƒ½
â”‚   â”œâ”€â”€ layout.tsx       # ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰å°‚ç”¨ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
â”‚   â””â”€â”€ page.tsx
â”œâ”€â”€ api/                 # API Route Handlers
â”‚   â””â”€â”€ users/
â”‚       â””â”€â”€ route.ts
â”œâ”€â”€ globals.css          # ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚¿ã‚¤ãƒ«
â”œâ”€â”€ layout.tsx           # ãƒ«ãƒ¼ãƒˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
â””â”€â”€ page.tsx             # ãƒ›ãƒ¼ãƒ ãƒšãƒ¼ã‚¸

lib/
â”œâ”€â”€ db/                  # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹é–¢é€£ï¼ˆDALï¼‰
â”‚   â”œâ”€â”€ index.ts         # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶š
â”‚   â”œâ”€â”€ queries.ts       # ã‚¯ã‚¨ãƒªé–¢æ•°
â”‚   â””â”€â”€ schema.ts        # ã‚¹ã‚­ãƒ¼ãƒå®šç¾©
â”œâ”€â”€ auth.ts              # èªè¨¼ãƒ­ã‚¸ãƒƒã‚¯
â”œâ”€â”€ utils.ts             # ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
â””â”€â”€ validations.ts       # ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¹ã‚­ãƒ¼ãƒ

actions/                 # Server Actions
â”œâ”€â”€ user-actions.ts      # ãƒ¦ãƒ¼ã‚¶ãƒ¼é–¢é€£ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
â”œâ”€â”€ post-actions.ts      # æŠ•ç¨¿é–¢é€£ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
â””â”€â”€ auth-actions.ts      # èªè¨¼é–¢é€£ã‚¢ã‚¯ã‚·ãƒ§ãƒ³

components/
â”œâ”€â”€ ui/                  # UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”œâ”€â”€ forms/               # ãƒ•ã‚©ãƒ¼ãƒ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â””â”€â”€ providers/           # ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
```

## ğŸš€ Server Actions ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### 1. Server Action ã®åŸºæœ¬æ§‹é€ 
```typescript
'use server'

import { revalidatePath } from 'next/cache'
import { redirect } from 'next/navigation'
import { z } from 'zod'
import { auth } from '@/lib/auth'

// ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¹ã‚­ãƒ¼ãƒ
const CreatePostSchema = z.object({
  title: z.string().min(1, 'ã‚¿ã‚¤ãƒˆãƒ«ã¯å¿…é ˆã§ã™'),
  content: z.string().min(10, 'å†…å®¹ã¯10æ–‡å­—ä»¥ä¸Šã§å…¥åŠ›ã—ã¦ãã ã•ã„'),
})

export async function createPost(formData: FormData) {
  // 1. èªè¨¼ãƒã‚§ãƒƒã‚¯
  const user = await auth()
  if (!user) {
    throw new Error('èªè¨¼ãŒå¿…è¦ã§ã™')
  }

  // 2. ãƒ‡ãƒ¼ã‚¿ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
  const validatedFields = CreatePostSchema.safeParse({
    title: formData.get('title'),
    content: formData.get('content'),
  })

  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // 3. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ“ä½œ
  try {
    const post = await createPostInDB({
      ...validatedFields.data,
      userId: user.id,
    })

    // 4. ã‚­ãƒ£ãƒƒã‚·ãƒ¥å†æ¤œè¨¼
    revalidatePath('/dashboard/posts')
    
    return { success: true, post }
  } catch (error) {
    return { error: 'æŠ•ç¨¿ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ' }
  }
}
```

### 2. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ‘ã‚¿ãƒ¼ãƒ³
```typescript
// actions/user-actions.ts
'use server'

import { z } from 'zod'

type ActionResult = {
  success?: boolean
  error?: string
  errors?: Record<string, string[]>
}

export async function updateProfile(
  prevState: ActionResult,
  formData: FormData
): Promise<ActionResult> {
  try {
    // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    const result = ProfileSchema.safeParse({
      name: formData.get('name'),
      email: formData.get('email'),
    })

    if (!result.success) {
      return {
        errors: result.error.flatten().fieldErrors,
      }
    }

    // å‡¦ç†å®Ÿè¡Œ
    await updateUserProfile(result.data)
    
    revalidatePath('/profile')
    return { success: true }
    
  } catch (error) {
    console.error('Profile update failed:', error)
    return { error: 'ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ' }
  }
}
```

### 3. ãƒ•ã‚©ãƒ¼ãƒ ã¨ã®çµ±åˆï¼ˆuseActionStateä½¿ç”¨ï¼‰
```typescript
// components/forms/profile-form.tsx
'use client'

import { useActionState } from 'react'
import { updateProfile } from '@/actions/user-actions'

export function ProfileForm({ user }) {
  const [state, formAction, pending] = useActionState(updateProfile, {})

  return (
    <form action={formAction}>
      <input 
        name="name" 
        defaultValue={user.name}
        required 
      />
      {state.errors?.name && (
        <p className="text-red-500">{state.errors.name[0]}</p>
      )}
      
      <button type="submit" disabled={pending}>
        {pending ? 'æ›´æ–°ä¸­...' : 'æ›´æ–°'}
      </button>
      
      {state.error && (
        <p className="text-red-500">{state.error}</p>
      )}
    </form>
  )
}
```

## ğŸ—„ï¸ DAL (Data Access Layer) ãƒ‘ã‚¿ãƒ¼ãƒ³

### 1. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã¨ã‚¯ã‚¨ãƒªåˆ†é›¢
```typescript
// lib/db/index.ts
import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const db = globalForPrisma.prisma ?? new PrismaClient()

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = db
```

### 2. React Cache ã¨Server-Only ã‚’ä½¿ç”¨ã—ãŸDAL
```typescript
// lib/db/queries.ts
import { cache } from 'react'
import 'server-only'
import { db } from './index'
import { auth } from '@/lib/auth'

// ãƒ¦ãƒ¼ã‚¶ãƒ¼é–¢é€£ã‚¯ã‚¨ãƒª
export const getCurrentUser = cache(async () => {
  const session = await auth()
  if (!session?.user?.id) return null
  
  return await db.user.findUnique({
    where: { id: session.user.id },
    include: { posts: true },
  })
})

export const getUserById = cache(async (id: string) => {
  return await db.user.findUnique({
    where: { id },
    select: {
      id: true,
      name: true,
      email: true,
      image: true,
    },
  })
})

// æŠ•ç¨¿é–¢é€£ã‚¯ã‚¨ãƒª
export const getPostsByUserId = cache(async (userId: string) => {
  return await db.post.findMany({
    where: { userId },
    include: {
      author: {
        select: { name: true, image: true },
      },
    },
    orderBy: { createdAt: 'desc' },
  })
})

export const getPublicPosts = cache(async (page = 1, limit = 10) => {
  const skip = (page - 1) * limit
  
  return await db.post.findMany({
    where: { published: true },
    include: {
      author: {
        select: { name: true, image: true },
      },
    },
    skip,
    take: limit,
    orderBy: { createdAt: 'desc' },
  })
})
```

### 3. èªè¨¼ä»˜ãDALé–¢æ•°
```typescript
// lib/db/secure-queries.ts
import { cache } from 'react'
import 'server-only'
import { auth } from '@/lib/auth'
import { db } from './index'

export const getMyPosts = cache(async () => {
  const user = await auth()
  if (!user) throw new Error('èªè¨¼ãŒå¿…è¦ã§ã™')
  
  return await db.post.findMany({
    where: { userId: user.id },
    include: {
      _count: { select: { comments: true } },
    },
    orderBy: { updatedAt: 'desc' },
  })
})

export const getMyProfile = cache(async () => {
  const user = await auth()
  if (!user) throw new Error('èªè¨¼ãŒå¿…è¦ã§ã™')
  
  return await db.user.findUnique({
    where: { id: user.id },
    include: {
      posts: { select: { id: true, title: true, published: true } },
      _count: { select: { posts: true, comments: true } },
    },
  })
})
```

## ğŸ“Š ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚§ãƒƒãƒãƒ‘ã‚¿ãƒ¼ãƒ³

### 1. ä¸¦åˆ—ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚§ãƒƒãƒ
```typescript
// app/dashboard/page.tsx
import { Suspense } from 'react'
import { getMyPosts, getMyProfile } from '@/lib/db/secure-queries'

export default async function DashboardPage() {
  // ä¸¦åˆ—ã§ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
  const userPromise = getMyProfile()
  const postsPromise = getMyPosts()
  
  const [user, posts] = await Promise.all([userPromise, postsPromise])
  
  return (
    <div>
      <h1>ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰</h1>
      <UserProfile user={user} />
      <Suspense fallback={<PostsSkeleton />}>
        <PostsList posts={posts} />
      </Suspense>
    </div>
  )
}
```

### 2. ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã¨ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹
```typescript
// app/posts/page.tsx
import { Suspense } from 'react'
import { getPublicPosts } from '@/lib/db/queries'
import { PostsList } from '@/components/posts-list'

export default function PostsPage() {
  return (
    <div>
      <h1>æŠ•ç¨¿ä¸€è¦§</h1>
      <Suspense fallback={<div>èª­ã¿è¾¼ã¿ä¸­...</div>}>
        <Posts />
      </Suspense>
    </div>
  )
}

async function Posts() {
  const posts = await getPublicPosts()
  return <PostsList posts={posts} />
}
```

## ğŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### 1. èªè¨¼ãƒ»èªå¯ãƒã‚§ãƒƒã‚¯
```typescript
// lib/auth.ts
import { cache } from 'react'
import 'server-only'
import { cookies } from 'next/headers'

export const auth = cache(async () => {
  const token = cookies().get('auth-token')?.value
  if (!token) return null
  
  try {
    // ãƒˆãƒ¼ã‚¯ãƒ³æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯
    const user = await verifyToken(token)
    return user
  } catch {
    return null
  }
})

export async function requireAuth() {
  const user = await auth()
  if (!user) {
    throw new Error('èªè¨¼ãŒå¿…è¦ã§ã™')
  }
  return user
}
```

### 2. Data Security with Taint API
```typescript
// lib/db/secure-queries.ts
import { experimental_taintObjectReference } from 'react'

export async function getUserWithSensitiveData(id: string) {
  const user = await db.user.findUnique({
    where: { id },
    include: { sensitiveInfo: true },
  })
  
  if (user) {
    // æ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«é€ä¿¡ã•ã‚Œãªã„ã‚ˆã†ã«ã™ã‚‹
    experimental_taintObjectReference(
      'ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«é€ä¿¡ã—ãªã„ã§ãã ã•ã„',
      user.sensitiveInfo
    )
  }
  
  return user
}
```

## âš¡ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

### 1. ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥
```typescript
// lib/cache.ts
import { unstable_cache } from 'next/cache'
import { cache } from 'react'

// Next.js ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆæ°¸ç¶šçš„ï¼‰
export const getCachedPosts = unstable_cache(
  async () => {
    return await db.post.findMany({
      where: { published: true },
      orderBy: { createdAt: 'desc' },
    })
  },
  ['public-posts'],
  {
    revalidate: 3600, // 1æ™‚é–“
    tags: ['posts'],
  }
)

// React ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆãƒªã‚¯ã‚¨ã‚¹ãƒˆå˜ä½ï¼‰
export const getPostBySlug = cache(async (slug: string) => {
  return await db.post.findUnique({
    where: { slug },
    include: { author: true, comments: true },
  })
})
```

### 2. æ–°ã—ã„ use cache ãƒ‡ã‚£ãƒ¬ã‚¯ãƒ†ã‚£ãƒ–ï¼ˆå®Ÿé¨“çš„ï¼‰
```typescript
// app/static-page.tsx
'use cache'
import { cacheLife } from 'next/cache'

export default async function StaticPage() {
  cacheLife('hours') // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚’è¨­å®š
  
  const data = await fetch('https://api.example.com/data')
  return <div>{/* é™çš„ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ */}</div>
}
```

## ğŸ”„ çŠ¶æ…‹ç®¡ç†ã¨ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°

### 1. Optimistic Updates
```typescript
// components/post-form.tsx
'use client'

import { useOptimistic } from 'react'
import { createPost } from '@/actions/post-actions'

export function PostForm({ posts }) {
  const [optimisticPosts, addOptimisticPost] = useOptimistic(
    posts,
    (state, newPost) => [...state, newPost]
  )
  
  async function formAction(formData: FormData) {
    const newPost = {
      id: Date.now().toString(),
      title: formData.get('title'),
      content: formData.get('content'),
      pending: true,
    }
    
    addOptimisticPost(newPost)
    await createPost(formData)
  }
  
  return (
    <form action={formAction}>
      {/* ãƒ•ã‚©ãƒ¼ãƒ è¦ç´  */}
    </form>
  )
}
```

### 2. ã‚­ãƒ£ãƒƒã‚·ãƒ¥å†æ¤œè¨¼
```typescript
// actions/post-actions.ts
'use server'

import { revalidatePath, revalidateTag } from 'next/cache'

export async function publishPost(postId: string) {
  await db.post.update({
    where: { id: postId },
    data: { published: true },
  })
  
  // ç‰¹å®šãƒ‘ã‚¹ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç„¡åŠ¹åŒ–
  revalidatePath('/posts')
  revalidatePath(`/posts/${postId}`)
  
  // ã‚¿ã‚°ãƒ™ãƒ¼ã‚¹ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç„¡åŠ¹åŒ–
  revalidateTag('posts')
}
```

## ğŸ“ å‹å®‰å…¨æ€§ã¨ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³

### 1. Zodã‚¹ã‚­ãƒ¼ãƒå®šç¾©
```typescript
// lib/validations.ts
import { z } from 'zod'

export const CreatePostSchema = z.object({
  title: z.string().min(1, 'ã‚¿ã‚¤ãƒˆãƒ«ã¯å¿…é ˆã§ã™').max(100),
  content: z.string().min(10, 'å†…å®¹ã¯10æ–‡å­—ä»¥ä¸Šã§å…¥åŠ›ã—ã¦ãã ã•ã„'),
  published: z.boolean().default(false),
})

export const UpdateUserSchema = z.object({
  name: z.string().min(1, 'åå‰ã¯å¿…é ˆã§ã™'),
  email: z.string().email('æœ‰åŠ¹ãªãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'),
  bio: z.string().max(500).optional(),
})

export type CreatePost = z.infer<typeof CreatePostSchema>
export type UpdateUser = z.infer<typeof UpdateUserSchema>
```

### 2. å‹å®‰å…¨ãªServer Actions
```typescript
// actions/typed-actions.ts
'use server'

import { z } from 'zod'
import { CreatePostSchema } from '@/lib/validations'

export async function createPostAction(
  data: z.infer<typeof CreatePostSchema>
) {
  const validatedData = CreatePostSchema.parse(data)
  
  // å‹å®‰å…¨ãªå‡¦ç†
  await db.post.create({
    data: validatedData,
  })
}
```

## ğŸ§ª ãƒ†ã‚¹ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³

### 1. Server Actions ã®ãƒ†ã‚¹ãƒˆ
```typescript
// __tests__/actions/post-actions.test.ts
import { describe, it, expect, vi } from 'vitest'
import { createPost } from '@/actions/post-actions'

// ãƒ¢ãƒƒã‚¯
vi.mock('@/lib/auth', () => ({
  auth: vi.fn().mockResolvedValue({ id: 'user-1' }),
}))

describe('createPost', () => {
  it('should create a post successfully', async () => {
    const formData = new FormData()
    formData.append('title', 'Test Post')
    formData.append('content', 'This is a test post content.')
    
    const result = await createPost(formData)
    
    expect(result.success).toBe(true)
    expect(result.post).toBeDefined()
  })
})
```

## ğŸš¨ ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

### 1. ã‚¨ãƒ©ãƒ¼å¢ƒç•Œã¨ã‚¨ãƒ©ãƒ¼ãƒšãƒ¼ã‚¸
```typescript
// app/error.tsx
'use client'

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  return (
    <div>
      <h2>ä½•ã‹ãŒé–“é•ã£ã¦ã„ã¾ã™ï¼</h2>
      <button onClick={() => reset()}>å†è©¦è¡Œ</button>
    </div>
  )
}
```

### 2. ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
```typescript
// lib/error-handler.ts
export class AppError extends Error {
  constructor(
    message: string,
    public statusCode: number = 500,
    public code?: string
  ) {
    super(message)
    this.name = 'AppError'
  }
}

export function handleActionError(error: unknown) {
  if (error instanceof AppError) {
    return { error: error.message, code: error.code }
  }
  
  console.error('Unexpected error:', error)
  return { error: 'äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ' }
}
```

## ğŸ”§ é–‹ç™ºãƒ„ãƒ¼ãƒ«ã¨è¨­å®š

### 1. Next.js è¨­å®š
```typescript
// next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    dynamicIO: true, // æ–°ã—ã„ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚·ã‚¹ãƒ†ãƒ 
    taint: true,     // Data Security
  },
  logging: {
    fetches: {
      fullUrl: true, // ãƒ•ã‚§ãƒƒãƒãƒ­ã‚°ã‚’è©³ç´°è¡¨ç¤º
    },
  },
}

export default nextConfig
```

### 2. TypeScriptè¨­å®š
```json
{
  "compilerOptions": {
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true
  }
}
```

ã“ã®ã‚¬ã‚¤ãƒ‰ã¯ Next.js App Router ã§ã®é–‹ç™ºã«ãŠã‘ã‚‹åŒ…æ‹¬çš„ãªãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚Server Actions ã®åŠ¹æœçš„ãªä½¿ç”¨ã€é©åˆ‡ãª DAL ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å®Ÿè£…ã€ãã—ã¦æœ€æ–°ã® React æ©Ÿèƒ½ã‚’æ´»ç”¨ã—ãŸãƒ¢ãƒ€ãƒ³ãªé–‹ç™ºæ‰‹æ³•ã‚’ç¿’å¾—ã§ãã¾ã™ã€‚


